import d3 from "d3";
// import _ from "lodash";

function collide(node) {
    return function(quad) {
      var updated = false;
      var padding = 0;
      if (quad.point && (quad.point !== node)) {
        var x = node.x - quad.point.x,
                y = node.y - quad.point.y,
                xSpacing = (quad.point.width + node.width + padding) / 2,
                ySpacing = (quad.point.height + node.height + padding) / 2,
                absX = Math.abs(x),
                absY = Math.abs(y),
                l,
                lx,
                ly;

        if (absX < xSpacing && absY < ySpacing) {
            l = Math.sqrt(x * x + y * y);

            lx = (absX - xSpacing) / l;
            ly = (absY - ySpacing) / l;

            // the one that"s barely within the bounds probably triggered the collision
            if (Math.abs(lx) > Math.abs(ly)) {
                    lx = 0;
            } else {
                    ly = 0;
            }

            node.x -= x *= lx;
            node.y -= y *= ly;
            quad.point.x += x;
            quad.point.y += y;

            updated = true;
        }
      }
      return updated;
    };

}

function create(el, props, state) {
  var tagData = state.tagData;
  var docData = state.docData;
  var force = this.force;
  var height = props.height;
  var width = props.width;

  console.log("props", props);
  console.log("state", state);

  var div = d3.select(el);

  force.nodes(tagData.concat(docData));
  force.size([props.width, props.height]);

  var word = div.selectAll("div.word")
     .data(tagData, d => d.key)
     .enter()
     .append("div")
     .call(function() {
        var wordScale = d3.scale.linear()
          .domain(d3.extent(tagData, d => d.values.length))
          .rangeRound([12, 30], 0, 0);

        this
          .attr("class", "word")
          .style("font-size", d => wordScale(d.values.length) + "px")
          .text(d => d.key)
          .call(force.drag);

        this.each(function(d){
          d.height = Math.ceil(this.getBoundingClientRect().height);
          d.width = Math.ceil(this.getBoundingClientRect().width);
        });

       this
          .style("transform", d => "translate(" + (-d.width / 2) + "px," + (-d.height/ 2) + "px)");
     });

  console.log("Word", word.data());

  var doc = div.selectAll(".doc")
    .data(docData, d => d.id);

  doc.enter()
    .insert("div", ":first-child")
    .call(function() {

    var xScale = d3.scale.ordinal()
      .domain(docData.map(d => d.id))
      .rangeRoundBands([props.margin.left, props.width + props.margin.left]);

      // TODO: cleanUp
      var doc = this
        .attr("class", "doc")
        .append("span")
        .attr("class", "content");
        // .style("background", "#FF851B")
        // .call(force.drag);
        // .call(drag);

      doc.append("div")
        .append("h4");
        // .text(d => d.title);

      doc
        .append("div")
          .attr("class", "live-example")
          // .style("z-index", d => d.z )
        .append("iframe")
          .attr("class", "link-preview");
          // .attr("src", "http://www.w3schools.com");
          //
      this.each(function(d){
        d.height = this.getBoundingClientRect().height;
        d.width = this.getBoundingClientRect().width;
      });

      this.each(function(d){
        d.height = this.getBoundingClientRect().height;
        d.width = this.getBoundingClientRect().width;
        d.fx = xScale(d.id);
        console.log("xScale", d.id);

        d.x2 = function() {
          return this.x + d.width;
        };
        d.y2 = function() {
          return this.y + d.height;
        };
        d.centerX = function() {
          return this.x + d.width / 2;
        };
        d.centerY = function() {
          return this.y + d.height / 2;
        };
      });

      doc
        .on("mouseover", d => {
          if (d.drag) return;
          if (force.alpha() > 0.1) return;
          // force.on("tick", tickDetail(doc, docScale, yScale));
          !d.selected ? d.selected = true : d.selected = false;
          // d.fixed = true;
          // force.start();

          console.log("d.tags", d.tags);
          var targets = d3.selectAll(".word")
                          .filter(e => d.tags.indexOf(e.key) !== -1);

          // var pos = $(targets[0]);
          console.log("targets", targets);
          //
          // var lines = d3.select("#svg").selectAll(".line")
          //                  .data(targets.data());
          //
          // lines.enter()
          //  .append("line")
          //    .attr("class", "line")
          //    .attr("x1", d.hx())
          //    .attr("y1", d.hy())
          //    .attr("x2", e => e.hx())
          //    .attr("y2", e => e.hy());

        })
        .on("mouseout", d => {
          // d3.selectAll(".line").remove();
          if (d.drag) return;
          if (force.alpha() > 0.1) return;

          d.selected = false;
          // d.fixed = false;
          // force.start();
        });
  });

  this.force.on("tick", function(e) {
    function moveToPos(pos, alpha, energy) {
        var affectSize = alpha * energy;
        return function(d) {
            d.x = d.x + (pos.x - d.x) * affectSize;
            d.y = d.y + (pos.y - d.y) * affectSize;
        };
    }
    function moveToY(y, alpha, energy) {
        var affectSize = alpha * energy;
        return function(d) {
            d.y = d.y + (y - d.y) * affectSize;
        };
    }


    var q = d3.geom.quadtree(tagData);
    tagData.forEach(d => q.visit(collide(d)));

    word.each(moveToY(height / 6, e.alpha, 0.5));


    doc.each(d => {
      var affectSize = e.alpha * 1.5;
      d.x += (d.fx - d.x) * affectSize;
      d.y += (props.height / 2 - d.y) * affectSize;
    });

    word
      .style("left", d => d.x + "px")
      .style("top", d => d.y + "px");

    d3.selectAll(".doc")
        .style("left", d => d.x + "px")
        .style("top", d => d.y + "px");

  });

  this.force.start();
}


// function ticker(doc) {
//   return function() {
//     doc.each(collideRect(doc.data()));
//     // doc.data().forEach(d => {
//     //   d.y = Math.max(1000, Math.min(d.y - 100, d.x));
//     // });
//     // doc.each(collide2(doc.data(), 0.1, 20));
//
//     doc
//       .style("transform", d => "translate(" + d.x + "px" + "," + d.y + "px)");
//       // .style("left", d => d.x + "px");
//       // .style("top", d => d.y + "px");
//   };
// }

const d3TagCloud = new function(){
  // var force = d3.layout.force()
  //               .charge(0);
  var force = d3.layout.force()
          .gravity(0.05)
          .charge(d => {
            var log = - d.height * 3;
            return log;
          });
          // .nodes(nodes)
          // .size([width, height]);
                // .gravity(0);
                // .friction(0.9
                // .linkDistance(l => {
                //   console.log("link", l);
                //   var len = l.source.values ? l.source.values.length : 0;
                //   return len > 1 ? l.source.values.length : 0;
                // })
                // .linkStrength(0)
                // .linkDistance(l => {
                  // var len = l.source.values ? l.source.values.length : 0;
                //   return l.value > 1 ? 500 : 0;
                // });
  return {
    force: force,
    update: null,
    create: create
  };
};

export default d3TagCloud;

// function draw(words) {
//   d3.select("body").append("svg")
//       .attr("width", layout.size()[0])
//       .attr("height", layout.size()[1])
//     .append("g")
//       .attr("transform", "translate(" + layout.size()[0] / 2 + "," + layout.size()[1] / 2 + ")")
//     .selectAll("text")
//       .data(words)
//     .enter().append("text")
//       .style("font-size", function(d) { return d.size + "px"; })
//       .style("font-family", "Impact")
//       .style("fill", function(d, i) { return fill(i); })
//       .attr("text-anchor", "middle")
//       .attr("transform", function(d) {
//         return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
//       })
//       .text(function(d) { return d.text; });
// }
